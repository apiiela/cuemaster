<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cuepoints — Full App</title>
  <style>
    :root{--bg:#0b0c10;--panel:#0f1117;--muted:#9aa3af;--text:#e6e8eb;--accent:#5b8cff;--ok:#22c55e}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial;color:var(--text);background:linear-gradient(180deg,#07070a,#0b0c10)}
    .app{max-width:1100px;margin:28px auto;padding:20px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:14px}
    h1{margin:0;font-size:1.2rem}
    .lead{margin:6px 0 0;color:var(--muted)}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03));border:1px solid rgba(255,255,255,0.03);padding:14px;border-radius:12px}
    .controls{display:flex;gap:8px;align-items:center;margin-bottom:12px}
    button{background:transparent;border:1px solid #222;padding:8px 10px;border-radius:8px;color:var(--text);cursor:pointer}
    button.primary{background:var(--accent);border:none;color:#051025}
    input[type=file]{display:none}
    .drop{border:2px dashed rgba(255,255,255,0.03);padding:18px;border-radius:10px;text-align:center;color:var(--muted);margin-bottom:12px}
    canvas{width:100%;height:140px;border-radius:8px;background:#051019;display:block}
    .time{font-variant-numeric:tabular-nums;color:var(--muted);min-width:90px;text-align:center;padding:6px;border-radius:8px}
    .cue-list{margin-top:12px;border-radius:10px;overflow:auto}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px 10px;text-align:left;border-bottom:1px solid rgba(255,255,255,0.02)}
    .swatch{width:18px;height:18px;border-radius:4px;display:inline-block;margin-right:8px;vertical-align:middle}
    .small{font-size:.9rem;color:var(--muted)}
    .kbd{border:1px solid rgba(255,255,255,0.06);padding:4px 6px;border-radius:6px;background:rgba(255,255,255,0.01)}
    .muted{color:var(--muted)}
    @media (max-width:800px){.cols{flex-direction:column}}
    .cols{display:flex;gap:12px}
    .col{flex:1}
    .notes{width:100%;min-width:120px}
    .flash{background:linear-gradient(90deg,#eaffea,#eaffea);color:#064e2f}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Cuepoints — Full App</h1>
        <div class="lead">Import audio, add and edit cue points with notes, save/load sessions. Timecode flashes green when a cue triggers.</div>
      </div>
      <div style="text-align:right">
        <div class="small">Shortcuts: <span class="kbd">Space</span>=Play, <span class="kbd">C</span>=Add cue, <span class="kbd">←/→</span>=Seek 5s</div>
      </div>
    </header>

    <div class="panel">
      <div class="controls">
        <label for="fileInputAudio"><button>Import audio</button></label>
        <input id="fileInputAudio" type="file" accept="audio/*">
        <button id="playBtn">Play ▶</button>
        <button id="addCueBtn">＋ Cue</button>
        <button id="jumpPrev">◀ Prev</button>
        <button id="jumpNext">Next ▶</button>
        <div style="flex:1"></div>
        <div id="timeDisplay" class="time">00:00.0</div>
      </div>

      <div class="drop" id="dropZone">Drop audio file here or use Import button</div>
      <canvas id="waveCanvas" width="1200" height="200" aria-label="Waveform"></canvas>

      <div class="cols" style="margin-top:12px">
        <div class="col">
          <div class="small">Cue list</div>
          <div class="cue-list" style="margin-top:8px">
            <table id="cueTable" aria-live="polite">
              <thead><tr><th>#</th><th>Time</th><th>Name</th><th>Notes</th><th>Colour</th><th></th></tr></thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

        <div style="width:300px">
          <div class="small">Actions</div>
          <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">
            <button id="downloadBtn">Download Session (.json)</button>
            <input type="file" id="fileInput" accept="application/json" style="display:none">
            <button id="openBtn">Open Session (.json)</button>
            <button id="exportCSV">Export CSV</button>
            <button id="saveLocal">Save locally</button>
            <button id="loadLocal">Load saved</button>
            <button id="clearCues">Clear cues</button>
            <div class="small muted">Loaded session replaces current cues. Use notes field to add rehearsal/design notes. Timecode flashes green for 400ms when a cue is hit.</div>
          </div>
        </div>
      </div>

    </div>

    <div class="small muted" style="margin-top:10px">This page is a standalone HTML app — you can save it and open locally. Works fully in-browser.</div>
  </div>

  <audio id="audioEl" crossorigin="anonymous" hidden></audio>

  <script>
    // Elements
    const fileInputAudio = document.getElementById('fileInputAudio');
    const fileInput = document.getElementById('fileInput');
    const openBtn = document.getElementById('openBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const exportCSV = document.getElementById('exportCSV');
    const saveLocal = document.getElementById('saveLocal');
    const loadLocal = document.getElementById('loadLocal');
    const clearCuesBtn = document.getElementById('clearCues');
    const playBtn = document.getElementById('playBtn');
    const addCueBtn = document.getElementById('addCueBtn');
    const jumpPrev = document.getElementById('jumpPrev');
    const jumpNext = document.getElementById('jumpNext');
    const timeDisplay = document.getElementById('timeDisplay');
    const cueTableBody = document.querySelector('#cueTable tbody');
    const dropZone = document.getElementById('dropZone');
    const audioEl = document.getElementById('audioEl');
    const waveCanvas = document.getElementById('waveCanvas');
    const ctx = waveCanvas.getContext('2d');

    let audioBuffer = null;
    let cues = []; // {id, time, name, notes, color, triggeredAt}
    let raf = null;

    function formatTime(t){ if(!isFinite(t)) t = 0; const m=Math.floor(t/60); const s=Math.floor(t%60); const d=Math.floor((t*10)%10); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${d}` }

    // Draw waveform once audioBuffer loaded
    function drawWaveform(buffer){
      const width = waveCanvas.width = Math.floor(waveCanvas.clientWidth * devicePixelRatio);
      const height = waveCanvas.height = 140 * devicePixelRatio;
      ctx.clearRect(0,0,width,height);
      if(!buffer) return;
      const data = buffer.getChannelData(0);
      const step = Math.ceil(data.length / width);
      ctx.fillStyle = '#06121a'; ctx.fillRect(0,0,width,height);
      ctx.fillStyle = '#27445b';
      for(let i=0;i<width;i++){
        const start = i*step; let min=1,max=-1;
        for(let j=0;j<step && start+j < data.length;j++){ const v=data[start+j]; if(v<min)min=v; if(v>max)max=v }
        const y1 = (1+min)/2*height; const y2 = (1+max)/2*height; ctx.fillRect(i, height - y2, 1, y2 - y1 || 1);
      }
    }

    function drawOverlay(){
      if(!audioBuffer) return;
      const width = waveCanvas.width; const height = waveCanvas.height;
      // redraw waveform lightly
      drawWaveform(audioBuffer);
      // draw cues
      cues.forEach(c=>{
        const x = (c.time / audioBuffer.duration) * width; ctx.fillStyle = c.color || '#7c5bff'; ctx.fillRect(Math.round(x)-1, 0, 3, height);
      });
      // playhead
      if(!isNaN(audioEl.currentTime) && audioBuffer.duration){ const px = (audioEl.currentTime / audioBuffer.duration) * width; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillRect(Math.round(px)-1,0,2,height); }
    }

    // Render cue table
    function renderCues(){
      cueTableBody.innerHTML = '';
      cues.sort((a,b)=>a.time-b.time);
      cues.forEach((c,i)=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${i+1}</td>
          <td><button class="seek" data-time="${c.time}">${formatTime(c.time)}</button></td>
          <td><input class="cue-name" data-id="${c.id}" value="${escapeHtml(c.name)}"></td>
          <td><input class="cue-notes notes" data-id="${c.id}" value="${escapeHtml(c.notes||'')}"></td>
          <td><input type="color" class="cue-col" data-id="${c.id}" value="${c.color||'#7c5bff'}"></td>
          <td><button class="del" data-id="${c.id}">Delete</button></td>
        `;
        cueTableBody.appendChild(tr);
      });
      drawOverlay();
    }

    function escapeHtml(s){ return String(s||'').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    function addCueAt(time){
      const t = Number(time ?? audioEl.currentTime ?? 0);
      const id = 'c'+Math.random().toString(36).slice(2,9);
      cues.push({id, time: Math.max(0, t), name: 'New cue', notes:'', color:'#7c5bff', triggeredAt: null});
      renderCues();
    }

    // File handling: import audio
    async function handleAudioFile(file){
      if(!file) return;
      const array = await file.arrayBuffer();
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      audioBuffer = await ac.decodeAudioData(array.slice(0));
      const blob = new Blob([array], {type: file.type || 'audio/*'});
      const url = URL.createObjectURL(blob);
      audioEl.src = url; audioEl.hidden = false;
      drawWaveform(audioBuffer);
      cues = cues || [];
      renderCues();
    }

    // Playback loop and cue trigger detection
    let lastCheckTime = 0;
    function onTick(){
      if(audioEl.duration && !isNaN(audioEl.currentTime)){
        timeDisplay.textContent = formatTime(audioEl.currentTime);
        // check cues between lastCheckTime and now
        const now = audioEl.currentTime;
        const windowStart = lastCheckTime; const windowEnd = now;
        // handle backwards seek
        if(windowEnd < windowStart){ cues.forEach(c=>c.triggeredAt = null); }
        cues.forEach(c=>{
          if(c.triggeredAt) return; // already triggered and not reset
          if(c.time >= windowStart - 0.02 && c.time <= windowEnd + 0.02){
            // trigger
            c.triggeredAt = Date.now();
            flashTimecode();
          }
        });
        lastCheckTime = now;
        drawOverlay();
      }
      raf = requestAnimationFrame(onTick);
    }

    function flashTimecode(){
      timeDisplay.classList.add('flash');
      setTimeout(()=> timeDisplay.classList.remove('flash'), 400);
    }

    // Button events
    fileInputAudio.addEventListener('change', e=> handleAudioFile(e.target.files[0]));
    dropZone.addEventListener('dragover', e=>{ e.preventDefault(); dropZone.style.borderColor='#3b6ee6'; });
    dropZone.addEventListener('dragleave', e=>{ e.preventDefault(); dropZone.style.borderColor=''; });
    dropZone.addEventListener('drop', e=>{ e.preventDefault(); dropZone.style.borderColor=''; handleAudioFile(e.dataTransfer.files[0]); });

    playBtn.addEventListener('click', ()=>{
      if(audioEl.paused){ audioEl.play(); playBtn.textContent='Pause ⏸'; lastCheckTime = audioEl.currentTime; raf = requestAnimationFrame(onTick); }
      else { audioEl.pause(); playBtn.textContent='Play ▶'; cancelAnimationFrame(raf); }
    });

    addCueBtn.addEventListener('click', ()=> addCueAt());
    window.addEventListener('keydown', e=>{
      if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      if(e.code === 'Space'){ e.preventDefault(); playBtn.click(); }
      if(e.key.toLowerCase() === 'c'){ e.preventDefault(); addCueAt(); }
      if(e.code === 'ArrowLeft'){ e.preventDefault(); audioEl.currentTime = Math.max(0, audioEl.currentTime - 5); }
      if(e.code === 'ArrowRight'){ e.preventDefault(); audioEl.currentTime = Math.min(audioEl.duration||0, audioEl.currentTime + 5); }
    });

    // Table delegation
    cueTableBody.addEventListener('click', e=>{
      const seek = e.target.closest('button.seek');
      const del = e.target.closest('button.del');
      if(seek){ audioEl.currentTime = Number(seek.dataset.time); drawOverlay(); }
      if(del){ const id = del.dataset.id; cues = cues.filter(c=>c.id !== id); renderCues(); }
    });

    cueTableBody.addEventListener('input', e=>{
      const name = e.target.closest('input.cue-name');
      const notes = e.target.closest('input.cue-notes');
      const col = e.target.closest('input.cue-col');
      if(name){ const id=name.dataset.id; const c = cues.find(x=>x.id===id); if(c) c.name = name.value; }
      if(notes){ const id=notes.dataset.id; const c = cues.find(x=>x.id===id); if(c) c.notes = notes.value; }
      if(col){ const id=col.dataset.id; const c = cues.find(x=>x.id===id); if(c) c.color = col.value; drawOverlay(); }
    });

    // Jump prev/next cue
    jumpPrev.addEventListener('click', ()=>{
      if(!cues.length) return; const t = audioEl.currentTime; const prev = [...cues].filter(c=>c.time < t-0.05).sort((a,b)=>b.time-a.time)[0]; if(prev) audioEl.currentTime = prev.time;
    });
    jumpNext.addEventListener('click', ()=>{
      if(!cues.length) return; const t = audioEl.currentTime; const next = [...cues].filter(c=>c.time > t+0.05).sort((a,b)=>a.time-b.time)[0]; if(next) audioEl.currentTime = next.time;
    });

    // Save/Load session (.json)
    downloadBtn.addEventListener('click', ()=>{
      const payload = {meta:{savedAt: new Date().toISOString()}, cues};
      const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
      const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='cuepoints-session.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    openBtn.addEventListener('click', ()=> fileInput.click());
    fileInput.addEventListener('change', e=>{
      const f = e.target.files[0]; if(!f) return; const reader = new FileReader(); reader.onload = ev=>{
        try{ const parsed = JSON.parse(ev.target.result); if(parsed.cues) cues = parsed.cues; else cues = parsed; // support plain array or object
          // ensure IDs exist
          cues = cues.map(c=>({ id: c.id || ('c'+Math.random().toString(36).slice(2,9)), time: Number(c.time), name: c.name||'Cue', notes:c.notes||'', color:c.color||'#7c5bff', triggeredAt:null }));
          renderCues();
        }catch(err){ alert('Failed to load session: '+err.message); }
      }; reader.readAsText(f);
    });

    // Export CSV
    exportCSV.addEventListener('click', ()=>{
      const rows = ['index,time,name,notes,color'];
      cues.forEach((c,i)=> rows.push([i+1, formatTime(c.time), `"${(c.name||'').replace(/"/g,'""')}\``, `"${(c.notes||'').replace(/"/g,'""')}\``, c.color||''].join(',')));
      const blob = new Blob([rows.join('\n')], {type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='cuepoints.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    // Local storage
    saveLocal.addEventListener('click', ()=>{ localStorage.setItem('cuepoints.session', JSON.stringify({savedAt: Date.now(), cues})); alert('Saved locally'); });
    loadLocal.addEventListener('click', ()=>{ const d = localStorage.getItem('cuepoints.session'); if(!d) return alert('No saved session'); try{ const parsed = JSON.parse(d); cues = parsed.cues||[]; cues = cues.map(c=>({ id: c.id || ('c'+Math.random().toString(36).slice(2,9)), time: Number(c.time), name:c.name||'Cue', notes:c.notes||'', color:c.color||'#7c5bff', triggeredAt:null })); renderCues(); }catch(e){ alert('Failed to load local'); } });

    clearCuesBtn.addEventListener('click', ()=>{ if(confirm('Clear all cues?')){ cues=[]; renderCues(); } });

    // Resize canvas on window resize
    let resizeTO; window.addEventListener('resize', ()=>{ clearTimeout(resizeTO); resizeTO=setTimeout(()=>{ if(audioBuffer) drawWaveform(audioBuffer); drawOverlay(); },150); });

    // initial empty waveform
    (function init(){ ctx.fillStyle='#06121a'; ctx.fillRect(0,0,waveCanvas.width,waveCanvas.height); ctx.fillStyle='#27445b'; ctx.fillRect(0,waveCanvas.height/2,waveCanvas.width,2); renderCues(); })();
  </script>
</body>
</html>
